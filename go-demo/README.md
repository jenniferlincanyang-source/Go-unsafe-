# 实践：用 Go(unsafe)理解“越界写如何破坏相邻内存”

## 目的与边界

本目录提供一个 **教育性** 示例：在 Go 中使用 `unsafe` 人为制造“越界写”，观察相邻内存（演示用的 `canary` 字段）被覆盖。

- Go 正常代码（不使用 `unsafe`/`cgo`）不会出现传统意义上的栈缓冲区溢出：数组/切片都有边界检查，越界会 `panic`。
- 本示例 **不** 展示控制流劫持（覆盖返回地址、构造 payload、绕过 ASLR/NX/Canary 等）的可操作步骤。

## 运行

在该目录下执行：

```bash
go run .
```

你将看到 `canary` 从初始值变成另一个值，说明 **越界写破坏了相邻内存**。

## 交互可视化网页

如果你更想“拖动/单步观察”越界写的过程，可以打开：

- `实践/overflow-viz/index.html`

